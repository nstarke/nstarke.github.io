<!DOCTYPE html>
<html>
<head>
<title>0048-smm-module-and-smi-handler-exploitation-patterns.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="beginning-smm-module-analysis">Beginning SMM Module Analysis</h1>
<p>Published April 18, 2021</p>
<p>I've recently become interested in &quot;going deeper&quot; in UEFI analysis, and thankfully there have been some excellent resources for learning about SMM Module exploitation.  I am currently looking at <a href="https://github.com/tandasat/SmmExploit">https://github.com/tandasat/SmmExploit</a> by <a href="https://twitter.com/standa_t">@standa_t</a>. The write up and corresponding exploit is beautifully written and documented, making learning from this example fairly straightforward.  I am hoping to identify code patterns that lead to vulnerabilities in order to extrapolate those patterns for analysis with other UEFI implementations. This blog post is more or less my notes as I begin to learn how to identify this type of vulnerability in SMI Handlers and SMM modules.</p>
<p>These notes will assume you are familiar with <a href="https://github.com/LongSoft/UEFITool">UEFITool</a> and either <a href="https://github.com/DSecurity/efiSeek">EfiSeek</a> or <a href="https://github.com/al3xtjames/ghidra-firmware-utils">ghidra-firmware-utils</a>.</p>
<h2 id="download-firmware-capsules">Download Firmware Capsules</h2>
<p>In the <code>SmmExploit</code> write up, the author provides well analyzed code output for the vulnerable and fixed code.  I wanted to see what the code output looks like without the excellent markup provided by the author.  I wanted to see the raw Ghidra decompiler output. To do so, I downloaded the vulnerable and fixed UEFI Update capsules from the ASUS website and loaded the <code>SdioSmm</code> module for both versions into Ghidra.  Direct links are provided below for the firmware:</p>
<ul>
<li>304 (Fixed) <a href="https://dlcdnets.asus.com/pub/ASUS/nb/UX360CA/UX360CAAS304.zip">https://dlcdnets.asus.com/pub/ASUS/nb/UX360CA/UX360CAAS304.zip</a></li>
<li>303 (Vulnerable) <a href="https://dlcdnets.asus.com/pub/ASUS/nb/UX360CA/UX360CAAS303.zip">https://dlcdnets.asus.com/pub/ASUS/nb/UX360CA/UX360CAAS303.zip</a></li>
</ul>
<h2 id="ghidra-decompiler-output">Ghidra Decompiler Output</h2>
<p>System management interrupts (SMI's) can be generated using the <code>OUT</code> x86_64 instruction. The first operand needs to be <code>0xb2</code> and then the second operand is the SMI &quot;code&quot;. The value for the SMI code determines which handler will handle the SMI. The code is specified at the time a SMI handler is registered. In the example below, this is the value of the variable <code>local_20</code>, which is <code>0x40</code>. It is possible to find the registration invocation by checking for all references of the SMI Handler function, which in this case is <code>swSmiHandler10</code> for the vulnerable version. Note that in the fixed firmware this handler function name is auto generated as <code>swSmiHandler11</code>.</p>
<p>SMI Handler Registration for <code>SdioSmm</code> module:</p>
<p>Fixed (304) Address: <code>0x80000c3a</code>
Vulnerable  (303) Address: <code>0x80000c56</code></p>
<pre class="hljs"><code><div>    local_20 = <span class="hljs-number">0x40</span>;
    EVar1 = (*EFI_SMM_SW_DISPATCH2_PROTOCOL7-&gt;Register)
                      (EFI_SMM_SW_DISPATCH2_PROTOCOL7,swSmiHandler10,&amp;local_20,&amp;local_28);
</div></code></pre>
<p>It is worth mentioning that the <code>OUT</code> instruction can only be executed in kernel mode (ring 0), so a kernel driver is the necessary vehicle for exploitation.  The <code>SmmExploit</code> demo code is written for Microsoft Windows, but I believe it would be possible to write a Linux version using LKM.</p>
<h2 id="identifying-patterns">Identifying Patterns</h2>
<p>Providing the &quot;raw&quot; or un-analyzed Ghidra decompiler output allowed me to identify a specific pattern that I think can be used for analyzing other firmware images. The pattern can be described as fist identifying input in the form of <code>uRam</code> addresses (in this example, <code>uRam000000000000040e</code>). Next we identify the SMRAM validation function that is meant to ensure memory buffers are located outside SMRAM.  I named this function <code>CheckIfBufferIsOutsideSmram</code>. Identifying the correct SMRAM validation function is important and I have provided a copy of the &quot;raw&quot; Ghidra decompiler output below. After we have identified these two components, we want to look for locations where user controlled input is used as part of the conditional check for the return value of <code>CheckIfBufferIsOutsideSmram</code>.  Conversely, it is worth mentioning that there might not be any such check, in which case any write to user-controlled memory addresses will result in a vulnerability. Lastly, we want to look for writes to memory that should be occuring outside SMRAM but because of either no checking or checking that involves user supplied input, can occur inside SMRAM.</p>
<p>So to recap, I would look for these three things when auditing a SMM Module for these types of vulnerabilities:</p>
<ol>
<li>Look for SMM modules that register a SMI Handler</li>
<li>Look for SMI handler's that read from <code>uRam</code> addresses</li>
<li>Look for SMI handlers that do some sort of checking for buffers located outside SMRAM.</li>
<li>Look for SMI handler's that write to user controlled addresses.</li>
</ol>
<h2 id="ghidra-decompiler-output">Ghidra Decompiler output</h2>
<p>In the vulnerable code, <code>pbVar2</code> is user controlled input to the SMI handler. This is a memory address which is user controlled.  The <code>SmmExploit</code> takes advantage of the <code>pbVar2</code> value being part of the conditional logic (<code>if ((lVar1 &lt; 0) || (3 &lt; *pbVar2))</code>) before a value is written to an offset of the user controlled address.</p>
<h2 id="smi-handler-code-vulnerable">SMI Handler Code (vulnerable)</h2>
<p>Vulnerable (303) Address: <code>0x80000c84</code></p>
<pre class="hljs"><code><div><span class="hljs-function">EFI_STATUS <span class="hljs-title">swSmiHandler10</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
  longlong lVar1;
  <span class="hljs-keyword">byte</span> *pbVar2;
  
  DAT_80001f60 = <span class="hljs-number">1</span>;
  pbVar2 = (<span class="hljs-keyword">byte</span> *)(ulonglong)*(uint *)(ulonglong)((uint)uRam000000000000040e * <span class="hljs-number">0x10</span> + <span class="hljs-number">0x104</span>);
  lVar1 = CheckIfBufferIsOutsideSmram((ulonglong)pbVar2,<span class="hljs-number">0x67</span>);
  <span class="hljs-keyword">if</span> ((lVar1 &lt; <span class="hljs-number">0</span>) || (<span class="hljs-number">3</span> &lt; *pbVar2)) {
    pbVar2[<span class="hljs-number">2</span>] = <span class="hljs-number">7</span>;
  }
  <span class="hljs-keyword">else</span> {
    (**(code **)(&amp;DAT_80000818 + (ulonglong)*pbVar2 * <span class="hljs-number">8</span>))(pbVar2);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="smi-handler-fixed">SMI Handler (fixed)</h2>
<p>Fixed (304) Address: <code>0x80000c68</code></p>
<pre class="hljs"><code><div><span class="hljs-function">EFI_STATUS <span class="hljs-title">swSmiHandler11</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
  longlong lVar1;
  <span class="hljs-keyword">byte</span> *pbVar2;
  
  DAT_80001f40 = <span class="hljs-number">1</span>;
  pbVar2 = (<span class="hljs-keyword">byte</span> *)(ulonglong)*(uint *)(ulonglong)((uint)uRam000000000000040e * <span class="hljs-number">0x10</span> + <span class="hljs-number">0x104</span>);
  lVar1 = CheckIfBufferIsOutsideSmram((ulonglong)pbVar2,<span class="hljs-number">0x67</span>);
  <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> &lt; lVar1) {
    <span class="hljs-keyword">if</span> (*pbVar2 &lt; <span class="hljs-number">7</span>) {
      (**(code **)(&amp;DAT_80000818 + (ulonglong)*pbVar2 * <span class="hljs-number">8</span>))(pbVar2);
    }
    <span class="hljs-keyword">else</span> {
      pbVar2[<span class="hljs-number">2</span>] = <span class="hljs-number">7</span>;
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>In many cases it will be useful to fingerprint the SMRAM validation function for use in analyzing other UEFI images.  I included the SMRAM validation function here so I can have a reference it for other implementations.</p>
<h2 id="smram-buffer-validation-function">SMRAM Buffer validation function</h2>
<p>Vulnerable (303) Address: <code>0x80001a74</code>
Fixed (304) Address: <code>0x80001a50</code></p>
<pre class="hljs"><code><div><span class="hljs-function">undefined8 <span class="hljs-title">CheckIfBufferIsOutsideSmram</span><span class="hljs-params">(ulonglong param_1,longlong param_2)</span>
</span>{
  ulonglong uVar1;
  undefined8 uVar2;
  ulonglong uVar3;
  ulonglong *puVar4;
  
  uVar3 = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (DAT_80001fc8 == <span class="hljs-number">0</span>) {
    uVar2 = <span class="hljs-number">0x800000000000000e</span>;
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (param_1 + param_2 &lt; param_1) {
      uVar2 = <span class="hljs-number">0x8000000000000002</span>;
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (DAT_80001fc8 != <span class="hljs-number">0</span>) {
        puVar4 = (ulonglong *)(DAT_80001fc0 + <span class="hljs-number">8</span>);
        <span class="hljs-keyword">do</span> {
          uVar1 = *puVar4;
          <span class="hljs-keyword">if</span> (param_1 &lt; uVar1) {
LAB_80001ad6:
            <span class="hljs-keyword">if</span> (uVar1 &lt; param_1 + param_2) {
              <span class="hljs-keyword">return</span> <span class="hljs-number">0x800000000000000f</span>;
            }
          }
          <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (param_1 &lt; uVar1 + puVar4[<span class="hljs-number">1</span>]) {
              <span class="hljs-keyword">return</span> <span class="hljs-number">0x800000000000000f</span>;
            }
            <span class="hljs-keyword">if</span> (param_1 &lt; uVar1) <span class="hljs-keyword">goto</span> LAB_80001ad6;
          }
          uVar3 = uVar3 + <span class="hljs-number">1</span>;
          puVar4 = puVar4 + <span class="hljs-number">4</span>;
        } <span class="hljs-keyword">while</span> (uVar3 &lt; DAT_80001fc8);
      }
      uVar2 = <span class="hljs-number">0</span>;
    }
  }
  <span class="hljs-keyword">return</span> uVar2;
}
</div></code></pre>
<p>I extend my sincere gratitude to <a href="https://twitter.com/standa_t">@standa_t</a> for answering my questions regarding his research, as well as for providing such well-written documentation on <a href="https://github.com/tandasat/SmmExploit">SmmExploit</a>.</p>
<p><a href="/">Back</a></p>

</body>
</html>
